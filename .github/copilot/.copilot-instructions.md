# Copilot Instructions for Invoicer Project

## Project Overview

Invoicer is a Next.js application designed to handle document processing and conversion to structured formats (JSON/CSV).

## Package Management

### Frontend (Next.js)

- Always use `pnpm` as the package manager
- Install dependencies using CLI commands:

```bash
# Adding dependencies
pnpm add <package-name>

# Adding dev dependencies
pnpm add -D <package-name>

# Updating dependencies
pnpm update <package-name>

# Installing all dependencies
pnpm install
```

### Backend (FastAPI - backend2)

- **ALWAYS activate the virtual environment before any operations**
- Use Python's `venv` for dependency isolation
- All Python commands MUST be run inside the virtual environment

```bash
# Navigate to backend2
cd backend2

# Activate virtual environment (REQUIRED before any operation)
source venv/bin/activate  # Linux/macOS
# or
.\venv\Scripts\activate  # Windows

# Install dependencies
pip install -r requirements.txt

# Add new dependencies
pip install <package-name>
pip freeze > requirements.txt  # Update requirements file

# Run the backend server
uvicorn app.main:app --reload --port 8000

# Run database migrations
alembic upgrade head

# Create new migration
alembic revision --autogenerate -m "Description"

# Deactivate when done
deactivate
```

**IMPORTANT**: Never run Python commands without activating venv first!

## Scalability Guidelines

### Code Organization

- Place reusable components in `/components`
- Place page-specific components in their respective page directories
- Use `/lib` for utility functions and shared logic
- Keep `/hooks` for custom React hooks
- Store types in `/types` directory

### Performance

- Implement lazy loading for components when possible
- Use Next.js Image component for optimized image loading
- Implement proper caching strategies
- Use React.memo() for expensive computations

### State Management

- Use React Context for global state when needed
- Implement proper state isolation
- Consider using Zustand for complex state management

## Maintainability Guidelines

### Code Style

- Follow consistent naming conventions:
  - Components: PascalCase
  - Functions: camelCase
  - Files: kebab-case
- Use TypeScript for type safety
- Implement proper error handling
- Write meaningful comments for complex logic

### Testing

- Write unit tests for components
- Implement integration tests for critical flows
- Use proper test naming conventions
- Maintain test coverage

### Documentation

- Document component props using TypeScript interfaces
- Add JSDoc comments for complex functions
- Keep README.md updated with new features
- Document environment variables

## Separation of Concerns

### Component Structure

```
components/
  ui/           # Reusable UI components
  forms/        # Form-related components
  layout/       # Layout components
  features/     # Feature-specific components
```

### Logic Separation

- Keep business logic in separate services
- Use custom hooks for shared behaviors
- Implement proper data fetching patterns
- Separate UI and logic concerns

### API Integration

- Keep API calls in separate service files
- Implement proper error handling
- Use TypeScript interfaces for API responses
- Implement proper loading states

## Developer Friendly Practices

### Code Organization

- Maintain consistent file structure
- Use absolute imports
- Keep components focused and small
- Follow single responsibility principle

### Development Flow

- Use proper Git commit messages
- Implement proper branch naming
- Document breaking changes
- Keep dependencies updated

### Error Handling

```typescript
// Example error handling pattern
try {
  // Operation
} catch (error) {
  if (error instanceof CustomError) {
    // Handle specific error
  } else {
    // Handle generic error
  }
}
```

### Component Template

```typescript
// Example component structure
import { type FC } from 'react'
import { type ComponentProps } from './types'

export const Component: FC<ComponentProps> = ({
  prop1,
  prop2,
}) => {
  // State and hooks

  // Helper functions

  // Effects

  // Render
  return (
    // JSX
  )
}
```

## Dependency Installation Guidelines

### UI Dependencies

```bash
pnpm add @radix-ui/react-dialog
pnpm add @radix-ui/react-dropdown-menu
pnpm add @radix-ui/react-slot
```

### Development Dependencies

```bash
pnpm add -D eslint
pnpm add -D prettier
pnpm add -D typescript
```

### Common Dependencies

```bash
pnpm add zod           # Schema validation
pnpm add axios         # HTTP client
pnpm add date-fns      # Date utilities
pnpm add react-query   # Data fetching
```

## File Structure

```
invox/
├── app/               # Next.js app directory
├── components/        # Reusable components
├── hooks/            # Custom React hooks
├── lib/              # Utilities and helpers
├── pages/            # Page components
├── public/           # Static assets
├── styles/           # Global styles
├── types/            # TypeScript types
└── backend2/         # FastAPI backend
    ├── app/
    │   ├── api/      # API endpoints
    │   ├── core/     # Configuration
    │   ├── db/       # Database
    │   ├── models/   # SQLAlchemy models
    │   ├── schemas/  # Pydantic schemas
    │   └── services/ # Business logic
    ├── alembic/      # Database migrations
    ├── venv/         # Virtual environment (DO NOT COMMIT)
    ├── .env          # Environment variables (DO NOT COMMIT)
    └── requirements.txt
```

## Best Practices

### Frontend Best Practices

1. Always implement proper loading states
2. Handle edge cases and errors
3. Implement proper form validation
4. Use proper TypeScript types
5. Keep components focused and small
6. Implement proper SEO practices
7. Follow accessibility guidelines
8. Implement proper testing
9. Use proper code splitting
10. Keep dependencies updated

### Backend Best Practices (FastAPI)

1. **ALWAYS use virtual environment** - Never run Python commands without activating venv
2. **Database connections** - Use `postgresql+psycopg://` dialect for psycopg3 driver
3. **Environment variables** - Never commit `.env` file, use `.env.example` as template
4. **Migrations** - Create Alembic migrations for all schema changes
5. **API design** - Follow RESTful conventions
6. **Error handling** - Use proper HTTP status codes and error messages
7. **Security** - Validate all inputs, use JWT for authentication
8. **Code organization** - Keep endpoints thin, business logic in services
9. **Testing** - Test all endpoints with proper test coverage
10. **Documentation** - Swagger docs auto-generated at `/docs`

### Backend Development Workflow

```bash
# 1. Always start by activating venv
cd backend2 && source venv/bin/activate

# 2. Make code changes

# 3. If models changed, create migration
alembic revision --autogenerate -m "Description"

# 4. Apply migrations
alembic upgrade head

# 5. Run/restart server
uvicorn app.main:app --reload --port 8000

# 6. Test endpoints at http://localhost:8000/docs

# 7. Deactivate when done
deactivate
```

Don't Create Documentation for prompts until said to do so
